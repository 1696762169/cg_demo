#version 430 core 
#define MIN_LEVEL 0
#define MAX_LEVEL 5
// #define MIN_LEVEL 0
// #define MAX_LEVEL 5

#define MIN_DISTANCE 0
#define MAX_DISTANCE 2
// #define MIN_DISTANCE 1
// #define MAX_DISTANCE 50

#define TESS_PER_CHUNK 4
// #define MAX_DISTANCE 50

layout(local_size_x=1,local_size_y=1,local_size_z=1) in;

// in uint gl_LocalInvocationIndex ;

struct Object{
    vec4 Position;
    vec2 TexCoords; 
};

layout(std430, binding=1) buffer Vertices{
    // uint vertexCnt;
    Object vertices[]; // all generated vertices
};

layout(std430, binding=2) buffer Indices{
    // uint indexCnt; 
    uint indices[]; // indice arrays (EBO)
};

struct Node{
    uvec4 indices; // vertex indice of 4 ends of a quad
};

layout(std430,binding=3) buffer InQueue{
    uint nodeCnt;  // nodes that need calculation 
    uint one;
    uint one_;
    Node nodes[]; // nodes needed calculation this round
}inQueue;

layout(std430,binding=4) buffer OutQueue{
    uint nodeCnt; // set to 0 before every iteration 
    uint one; 
    uint one_;
    Node nodes[]; // nodes that need further calculation
}outQueue;

layout(std430, binding=5) buffer OutIndirect {
	uint count;
	uint primCount;
	uint firstIndex;
	uint baseVertex;
	int baseInstance;
    uint vertexCnt;
}; // indirect draw 


layout(std140,binding=0) uniform VP{
    mat4 projection; 
    mat4 view; 
};
uniform mat4 model; 

uniform float yShift;
uniform float yScale;

uniform int iteration;  // 第几次执行该 compute shader

uniform sampler2D heightMap;

int GetLODLevel(Object object[4]){
// left 
    vec4 camPosition[4]; 
    for(int i =0;i<4;i++){
        camPosition[i] = projection * view * model * vec4(object[i].Position.xyz,1.0f);
    }

    float len1 = length((camPosition[0]/camPosition[0].w-camPosition[2]/camPosition[2].w).xy);
    float len2 = length((camPosition[1]/camPosition[1].w - camPosition[3]/camPosition[3].w).xy);
    float minL = min(len1,len2);
    int level = int(MAX_LEVEL * (minL-MIN_DISTANCE)/(MAX_DISTANCE));
    level = clamp(level,MIN_LEVEL,MAX_LEVEL);
    return MAX_LEVEL - level;
    // vec4 eyeSpacePos[4];
    // for(int i =0;i<4;i++){
    //     eyeSpacePos[i] = view * model * vec4(vertices[i].Position.xyz,1.0f);
    // }
    // // "distance" from camera scaled between 0 and 1
    // float pointDistance[4];
    // for(int i= 0;i<4;i++){
    //     pointDistance[i] = length(eyeSpacePos[i]);
    // }

    // float level[4]; 
    // for(int i=0;i<4;i++){
    //     // level[i] = log2(pointDistance[i]/MIN_DISTANCE + 1);
    //     level[i] = (pointDistance[i] + MIN_DISTANCE) / (MAX_DISTANCE + MIN_DISTANCE) * MAX_LEVEL;
    // }
    // // float maxLevel = max(level[0],max(level[1],max(level[2],level[3])));
    // float maxLevel = min(level[0],min(level[1],min(level[2],level[3])));
    // maxLevel = clamp(maxLevel, MIN_LEVEL, MAX_LEVEL);
    // return int(maxLevel);
}

bool needCulling(Object object[4]){
    // cohen-sutherland 
    vec4 NDC[4]; 
    bool flag = false;
    for(int i=0;i<4;i++){
        NDC[i] = projection * view * model * vec4(object[i].Position.xyz,1.0f);
    }
    // if(NDC[0].w < 0.0f && NDC[1].w <0.0f && NDC[2].w <0.0f && NDC[3].w < 0.0f){
    //     return true; 
    // }
    int code[4]; 
    for(int i=0;i<4;i++){
        NDC[i] = NDC[i] / NDC[i].w; 
        code[i] = 0;
        //x
        if(NDC[i].x < -1.1f){
            code[i] += (1<<4); 
        }else if (NDC[i].x <= 1.1f){
        }else{
            code[i] += (1<< 5);
        }
        //y
        if(NDC[i].y < -1.1f){
            code[i] += (1<<2); 
        }else if (NDC[i].y <= 1.1f){
        }else{
            code[i] += (1<<3);
        }
        //z
        if(NDC[i].z < -1.1f){
            code[i] += (1<<0); 
        }else if (NDC[i].z <= 1.1f){
        }else{
            code[i] += (1<<1);
        }
    }
    int AND = code[0] & code[1] & code[2] & code[3]; 
    int x_ = (AND >> 4); 
    int y_ = (AND >> 2)%4;
    int z_ = AND % 4;
    if(x_ > 0 || y_ >0 || z_ > 0)
        return true;
    return false;
    // return !flag; 
}

void generateLODData(int iter,Node n){
    Object Points[4]; 
    Points[0] = vertices[n.indices[0]];
    Points[1] = vertices[n.indices[1]];
    Points[2] = vertices[n.indices[2]];
    Points[3] = vertices[n.indices[3]];
    vec4 delta = Points[2].Position - Points[0].Position; 

    if(needCulling(Points)){
        return;
    };

    int currentLevel = GetLODLevel(Points);
    if(currentLevel + iter < MAX_LEVEL){
        // 生成新的点继续细分

        vec4 newPoint01 = 0.5*(Points[0].Position+ Points[1].Position);
        vec4 newPoint12 = 0.5*(Points[1].Position + Points[2].Position);
        vec4 newPoint23 = 0.5*(Points[2].Position + Points[3].Position); 
        vec4 newPoint03 = 0.5*(Points[3].Position + Points[0].Position); 
        vec4 newPointc = 0.5*(Points[0].Position + Points[2].Position); // center

        uint curVertexIndex = atomicAdd(vertexCnt,5);
        uint index01 = curVertexIndex; 
        uint index12 = curVertexIndex + 1;
        uint index23 = curVertexIndex + 2; 
        uint index30 = curVertexIndex + 3; 
        uint indexc = curVertexIndex + 4;
        vertices[index01].Position = newPoint01; //00 
        vertices[index12].Position = newPoint12; //01 
        vertices[index23].Position = newPoint23; //10
        vertices[index30].Position = newPoint03; //11
        vertices[indexc].Position = newPointc; // center

        vec2 UV01 = 0.5*(Points[0].TexCoords+ Points[1].TexCoords);
        vec2 UV12= 0.5*(Points[1].TexCoords+ Points[2].TexCoords);
        vec2 UV23= 0.5*(Points[2].TexCoords+ Points[3].TexCoords); 
        vec2 UV03= 0.5*(Points[3].TexCoords+ Points[0].TexCoords); 
        vec2 UVc= 0.5*(Points[0].TexCoords + Points[2].TexCoords); // center
        vertices[index01].TexCoords= UV01;//00 
        vertices[index12].TexCoords= UV12; //01 
        vertices[index23].TexCoords= UV23; //10
        vertices[index30].TexCoords= UV03; //11
        vertices[indexc].TexCoords= UVc; 

        Node newNode00; 
        Node newNode01; 
        Node newNode10;
        Node newNode11; 
        newNode00.indices = uvec4(n.indices[0],index01,indexc,index30);
        newNode01.indices = uvec4(index01,n.indices[1],index12,indexc);
        newNode10.indices = uvec4(indexc,index12,n.indices[2],index23);
        newNode11.indices = uvec4(index30,indexc,index23,n.indices[3]);

        uint curNodeIndex = atomicAdd(outQueue.nodeCnt,4);
        outQueue.nodes[curNodeIndex] = newNode00;
        outQueue.nodes[curNodeIndex+1] = newNode01;
        outQueue.nodes[curNodeIndex+2] = newNode10;
        outQueue.nodes[curNodeIndex+3] = newNode11;
    }else{
        // 不再细分，填写 indices
        // 一个 lod chunk 的边 分为 TESS_PER_CHUNK 个小块
        // decide whether this part needs culling
        // if(needCulling(Points))
            // return;
        uint NEW_VERTICES_COUNT = (TESS_PER_CHUNK+1) * (TESS_PER_CHUNK+1);
        uint curVertexIndex = atomicAdd(vertexCnt,NEW_VERTICES_COUNT);
        uint curIndiceIndex = atomicAdd(count,TESS_PER_CHUNK*TESS_PER_CHUNK*6);
        for(uint i=0;i<=TESS_PER_CHUNK;i++){
            for(uint j = 0;j<=TESS_PER_CHUNK;j++){
                vec2 uv = vec2(j*1.0f/TESS_PER_CHUNK,i*1.0f/TESS_PER_CHUNK);
                vec2 uv_ = vec2(
                    Points[0].TexCoords.x * (1-uv.x) + Points[2].TexCoords.x * uv.x,
                    Points[0].TexCoords.y * (1-uv.y) + Points[2].TexCoords.y * uv.y
                    );
                float height = texture(heightMap,uv_).r * yScale - yShift;
                uint index = curVertexIndex + i * (TESS_PER_CHUNK+1) + j;
                vertices[index].Position = 
                    Points[0].Position + vec4(j*delta.x/TESS_PER_CHUNK,
                    height,
                    i*delta.z/TESS_PER_CHUNK,0.0f);
                vertices[index].TexCoords = uv_;
            }
        }
        for(uint i=0;i<TESS_PER_CHUNK;i++){
            for(uint j =0;j<TESS_PER_CHUNK;j++){
                uint upper_left = i * (TESS_PER_CHUNK+1) + j + curVertexIndex; 
                indices[curIndiceIndex++] = upper_left; // 
                indices[curIndiceIndex++] = upper_left + (TESS_PER_CHUNK + 1);
                indices[curIndiceIndex++] = upper_left + 1; 

                indices[curIndiceIndex++] = upper_left + 1;
                indices[curIndiceIndex++] = upper_left + (TESS_PER_CHUNK + 1);
                indices[curIndiceIndex++] = upper_left + 1 +(TESS_PER_CHUNK+1);
            }
        }

    }
}

void main(){
    // LOD 
    uint nodeIndex = uint(gl_GlobalInvocationID);
    // DEBUG
    // uint curVertexIndex = atomicAdd(vertexCnt,1);
    // vertices[curVertexIndex] = vec4(float(gl_GlobalInvocationID),0.0f,0.0f,0.0f);

    generateLODData(iteration,inQueue.nodes[nodeIndex]);
}