#version 450 core

layout(local_size_x=1,local_size_y=1,local_size_z=1) in;

struct DensityProfileLayer{
    float width; // an atomosphere layer of width 'width'
    float exp_term;
    float exp_scale; 
    float linear_term; 
    float const_term; 
};

// two layers of atmosphere
struct DensityProfile{
    DensityProfileLayer layers[2]; 
};

uniform uint TexWidth;
uniform uint TexHeight;

struct AtmosphereParameters{
    float solar_irradiance; // solar irradiance at the top of the atmosphere
    float sun_angular_radius;
    float top_radius;
    float bottom_radius; 

    DensityProfile rayleigh_density; 
    vec3 rayleigh_scattering;//scattering coefficient of air molecules
    DensityProfile mie_density; 
    vec3 mie_scattering; // scattering cofficient, a function of wavelength.
    vec3 mie_extinction; 
    float mie_g; // g coefficient in phase function

    DensityProfile absorption_density; //ozone layer
    vec3 absorption_extinction; 

    vec3 ground_albedo; // average albedo (can be replaced by gorund textures? perhaps)

    // cosine of maximum sun zenith angle. 
    // which is the smallest sun zenith angle yielding negligible 
    // sky light radiance values. Earth: 102 degress -> -0.2 
    float mu_s_min;
};

layout(rgba32f,binding=0) uniform image2D transmittanceTexture;

layout(std140, binding=7) uniform ATMOS{
    AtmosphereParameters atmosphere;
};

float DistanceToTop(AtmosphereParameters atmopshere,float r, float mu){
    // mu = cos theta 
    // r = polar radius
    if(r > atmosphere.top_radius)
        return -1; 
    if(mu < -1.0 || mu > 1.0)
        return -1;
    float discriminant = r * r * (mu * mu -1.0f) + atmopshere.top_radius * atmopshere.top_radius;
    if(discriminant < 0)
        return -1; 
    return (-r*mu+sqrt(discriminant));
}

float DistanceToBottom(AtmosphereParameters atmopshere,float r, float mu){
    // mu = cos theta 
    // r = polar radius
    if(r > atmosphere.top_radius)
        return -1; 
    if(mu < -1.0 || mu > 1.0)
        return -1;
    float discriminant = r * r * (mu * mu -1.0f) + atmopshere.top_radius * atmopshere.top_radius;
    if(discriminant < 0)
        return -1; 
    return (-r*mu-sqrt(discriminant));
}

bool RayIntersectsGround(AtmosphereParameters atmopshere,float r,float mu){
    return mu < 0.0 && r * r * (mu * mu - 1.0) +
      atmosphere.bottom_radius * atmosphere.bottom_radius >= 0.0;
}

float GetLayerDensity(DensityProfileLayer layer,float altitude){
    float density = layer.exp_term * exp(layer.exp_scale * altitude)
    + layer.linear_term * altitude + layer.const_term;
    return clamp(density, 0.0f, 1.0f);
}

float GetProfileDensity(DensityProfile profile,float altitude){
    return altitude < profile.layers[0].width ? 
        GetLayerDensity(profile.layers[0],altitude):
        GetLayerDensity(profile.layers[1],altitude);
}

// Optical Legnth: integral of density times distance
float ComputeOpticalLengthToTopAtmosphereBoundary(AtmosphereParameters atmosphere,DensityProfile profile,float r,float mu){
    const int SAMPLES = 500; 
    float dx = DistanceToTop(atmosphere,r,mu) / float(SAMPLES);
    float result = 0.0; 
    for(int i=0;i<=SAMPLES;i++){
        float d_i = float(i) * dx;
        // current sample point to planet center
        float r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);
        // density at given height, dimensionless.
        float y_i = GetProfileDensity(profile,r_i-atmosphere.bottom_radius);
        // sample weight 
        // trapezoidal rule
        float weight_i = i==0 || i==SAMPLES ? 0.5 : 1.0; 
        result += y_i * weight_i * dx;// compute integral
    }
    return result;
}

// compute dimensionless transmittance 
// given r and mu 
vec3 ComputeTransmittanceToTop(AtmosphereParameters atmosphere,float r, float mu){
    return exp(
        atmosphere.rayleigh_scattering *
          ComputeOpticalLengthToTopAtmosphereBoundary(
              atmosphere, atmosphere.rayleigh_density, r, mu) +
        atmosphere.mie_extinction *
          ComputeOpticalLengthToTopAtmosphereBoundary(
              atmosphere, atmosphere.mie_density, r, mu) +
        atmosphere.absorption_extinction *
          ComputeOpticalLengthToTopAtmosphereBoundary(
              atmosphere, atmosphere.absorption_density, r, mu)
    );
}

// float UnitToTexture(float x,int texture_size){
//     return 0.5 / float(texture_size) + x * (1.0f - 1.0f / float(texture_size));
// }

// float TextureToUnit(float u, int texture_size){
//     return (u - 0.5f / float(texture_size)) / (1.0f - 1.0f/float(texture_size));
// }



void GetRMuFromTransmittanceTextureUv(AtmosphereParameters atmosphere,
    in vec2 uv, out float r, out float mu) {
    float x_mu = uv.x;
    float x_r = uv.y; 
    // Distance to top atmosphere boundary for a horizontal ray at ground level.
    float H = sqrt(atmosphere.top_radius * atmosphere.top_radius -
        atmosphere.bottom_radius * atmosphere.bottom_radius);
    // Distance to the horizon, from which we can compute r:
    float rho = H * x_r;
    r = sqrt(rho * rho + atmosphere.bottom_radius * atmosphere.bottom_radius);
    // Distance to the top atmosphere boundary for the ray (r,mu), and its minimum
    // and maximum values over all mu - obtained for (r,1) and (r,mu_horizon) -
    // from which we can recover mu:
    float d_min = atmosphere.top_radius - r;
    float d_max = rho + H;
    float d = d_min + x_mu * (d_max - d_min);
    mu = ((abs(d-0.0f)<0.0005) ? 1.0f : (H * H - rho * rho - d * d) / (2.0 * r * d));
    mu = clamp(mu,-1.0f,1.0f);
}

void main(){
    // imageStore 
    vec2 uv = gl_WorkGroupID.xy;
    float r;
    float mu; 
    GetRMuFromTransmittanceTextureUv(atmosphere,uv,r,mu);
    vec3 transmittance = ComputeTransmittanceToTop(atmosphere,r,mu);
    ivec2 texelCoord = ivec2(int(uv.x * (TexWidth-1)),int(uv.y * (TexHeight-1)));
    imageStore(transmittanceTexture,texelCoord,vec4(transmittance,1.0f));
}